# импортируем метод, который позволяет преобразовать словарь Python в JSON
from flask import jsonify, request
import re
# импортируем объект приложения
from . import db, app
# импортируем модель
from .models import URLMap
from .error_handlers import InvalidAPIUsage
from .views import check_unique_short_id, get_unique_short_id


# создаем первую функцию get_url(id) для обработки GET-запроса
# к эндпоинту /api/id/<short_id>/:
# явно разрешим метод GET
# в качестве параметра передаем short_id
@app.route('/api/id/<short_id>/', methods=['GET'])
def get_url(short_id):
    """
    Функция для реализации GET-запроса на получение
    оригинальной ссылки по указанному короткому идентификатору.
    """

    # из GET-запроса получаем короткий идентификатор - short_id
    # запрашиваем объект модели URLMap по полученному short_id
    url_map_obj = URLMap.query.filter_by(short=short_id).first()
    if url_map_obj is None:
        # если объекта с таким коротким идентификатором не найдено в базе
        # то вернется ошибка 404(Not Found), но нам надо, чтобы вернулся JSONс понятным сообщением
        # об ошибке,а не HTML
        # поэтому напишем и применим кастомное исключение
        # в котором в зависимости от ошибки можно указать конкретное сообщение
        # и код ошибки
        raise InvalidAPIUsage('В базе данных нет такой ссылки', 404)
    # если же объект в базе данных найден, то из этого объекта нам нужно
    # "достать" оригинальную длинную ссылку и вернуть ее в виде
    # JSON-ответа
    original_link = url_map_obj.original
    # а уже потом передаем этот словарь в качестве значения словаря в метод
    # jsonify, конвертируем данные в JSON
    # также необходимо вернуть статус-код успешного выполнения запроса - 200
    return jsonify({'url': original_link}), 200


    # опишем вторую АПИ-функцию, добавляющую новый объект
    # обернем функцию в декоратор @app.route, чтобы связать данную функцию
    # с эндпоинтом, который указан в декораторе
    # явно укажем метод POST
@app.route('/api/id/', methods=['POST'])
def add_url():
    """
    Функция для реализации POST-запроса на создание новой короткой ссылки.
    """

    # получим данные из запроса в виде JSON
    # flask.request - объект, который анализирует данные входящих запросов и
    # предоставляет доступ к ним
    # get_json - метод, который возвращает разобранные данные входящих запросов
    data = request.get_json()
    # нужно учесть, что данные вообще могут не прийти в запросе
    # то есть, тело запроса оказалось пустым
    if not data:
        raise InvalidAPIUsage("Отсутствую данные в теле запроса.")
    # могут отсутствовать данные по оригинальной ссылке
    if 'url' not in data:
        raise InvalidAPIUsage("Отсутствует обязательная оригинальная ссылка в теле запроса.")
    # с коротким идентификатором нужно проверить несколько случаев
    # если он пришел в data, то нам нужно извлечь значение custom_id
    # из data с помощью метода get
    if 'custom_id' in data:
        custom_id = data.get('custom_id')
        # далее нужно проверить - уникальный ли короткий идентификатор пришел в data
        if not check_unique_short_id(custom_id):
            # если не уникальный, то нужно выбросить кастомное исключение с понятным текстом ошибки
            raise InvalidAPIUsage(f'Имя короткой ссылки "{custom_id}" уже занято.')
        # если в поле с коротким идннтификатором стоит просто пробел или оно пустое в принципе, то
        if custom_id == "" or custom_id is None:
            # то нужно сгенерировать новый короткий идент-р
            data['custom_id'] = get_unique_short_id()
        elif not re.match(r'^[a-zA-Z\d]{1,16}$', custom_id):
            raise InvalidAPIUsage('Недопустимое имя для короткой ссылки')
# если короткой ссылки вообще нет в data, то ее нужно добавить туда, сгенерировав с помощью
    # функции генерации короткого идентификатора
    else:
        data['custom_id'] = get_unique_short_id()

    new_url = URLMap()
    new_url.from_dict(data)
    db.session.add(new_url)
    db.session.commit()
    return jsonify(new_url.to_dict()), 201
